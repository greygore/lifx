// Code generated by "genlifx"; DO NOT EDIT.
package lan

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

// message types
const (
	LightGetType                 = 101
	LightGetInfraredType         = 120
	LightGetPowerType            = 116
	LightSetColorType            = 102
	LightSetInfraredType         = 122
	LightSetPowerType            = 117
	LightSetWaveformType         = 103
	LightSetWaveformOptionalType = 119
	LightStateType               = 107
	LightStateInfraredType       = 121
	LightStatePowerType          = 118
)

/////////////////////////////////////////////////////////////////////////////

type LightGet struct{}

func (m LightGet) Size() uint16 {
	return 0
}

func (m LightGet) Type() uint16 {
	return LightGetType
}

func (m LightGet) MarshalBinary() ([]byte, error) {
	return []byte{}, nil
}

func (m *LightGet) UnmarshalBinary(data []byte) error {
	if len(data) > 0 {
		return fmt.Errorf("expected empty packet, got %d bytes", len(data))
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightGetInfrared struct{}

func (m LightGetInfrared) Size() uint16 {
	return 0
}

func (m LightGetInfrared) Type() uint16 {
	return LightGetInfraredType
}

func (m LightGetInfrared) MarshalBinary() ([]byte, error) {
	return []byte{}, nil
}

func (m *LightGetInfrared) UnmarshalBinary(data []byte) error {
	if len(data) > 0 {
		return fmt.Errorf("expected empty packet, got %d bytes", len(data))
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightGetPower struct{}

func (m LightGetPower) Size() uint16 {
	return 0
}

func (m LightGetPower) Type() uint16 {
	return LightGetPowerType
}

func (m LightGetPower) MarshalBinary() ([]byte, error) {
	return []byte{}, nil
}

func (m *LightGetPower) UnmarshalBinary(data []byte) error {
	if len(data) > 0 {
		return fmt.Errorf("expected empty packet, got %d bytes", len(data))
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightSetColor struct {
	Reserved0 [1]byte
	Color     LightHsbk
	Duration  uint32
}

func (m LightSetColor) Size() uint16 {
	return 13
}

func (m LightSetColor) Type() uint16 {
	return LightSetColorType
}

func (m LightSetColor) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Reserved0,
		m.Color,
		m.Duration,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightSetColor) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Reserved0,
		&m.Color,
		&m.Duration,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightSetInfrared struct {
	Brightness uint16
}

func (m LightSetInfrared) Size() uint16 {
	return 2
}

func (m LightSetInfrared) Type() uint16 {
	return LightSetInfraredType
}

func (m LightSetInfrared) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Brightness,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightSetInfrared) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Brightness,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightSetPower struct {
	Level    uint16
	Duration uint32
}

func (m LightSetPower) Size() uint16 {
	return 6
}

func (m LightSetPower) Type() uint16 {
	return LightSetPowerType
}

func (m LightSetPower) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Level,
		m.Duration,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightSetPower) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Level,
		&m.Duration,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightSetWaveform struct {
	Reserved0 [1]byte
	Transient bool
	Color     LightHsbk
	Period    uint32
	Cycles    float32
	SkewRatio int16
	Waveform  LightWaveform
}

func (m LightSetWaveform) Size() uint16 {
	return 21
}

func (m LightSetWaveform) Type() uint16 {
	return LightSetWaveformType
}

func (m LightSetWaveform) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Reserved0,
		m.Transient,
		m.Color,
		m.Period,
		m.Cycles,
		m.SkewRatio,
		m.Waveform,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightSetWaveform) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Reserved0,
		&m.Transient,
		&m.Color,
		&m.Period,
		&m.Cycles,
		&m.SkewRatio,
		&m.Waveform,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightSetWaveformOptional struct {
	Reserved0     [1]byte
	Transient     bool
	Color         LightHsbk
	Period        uint32
	Cycles        float32
	SkewRatio     int16
	Waveform      LightWaveform
	SetHue        bool
	SetSaturation bool
	SetBrightness bool
	SetKelvin     bool
}

func (m LightSetWaveformOptional) Size() uint16 {
	return 25
}

func (m LightSetWaveformOptional) Type() uint16 {
	return LightSetWaveformOptionalType
}

func (m LightSetWaveformOptional) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Reserved0,
		m.Transient,
		m.Color,
		m.Period,
		m.Cycles,
		m.SkewRatio,
		m.Waveform,
		m.SetHue,
		m.SetSaturation,
		m.SetBrightness,
		m.SetKelvin,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightSetWaveformOptional) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Reserved0,
		&m.Transient,
		&m.Color,
		&m.Period,
		&m.Cycles,
		&m.SkewRatio,
		&m.Waveform,
		&m.SetHue,
		&m.SetSaturation,
		&m.SetBrightness,
		&m.SetKelvin,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightState struct {
	Color     LightHsbk
	Reserved1 [2]byte
	Power     uint16
	Label     [32]byte
	Reserved4 [8]byte
}

func (m LightState) Size() uint16 {
	return 52
}

func (m LightState) Type() uint16 {
	return LightStateType
}

func (m LightState) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Color,
		m.Reserved1,
		m.Power,
		m.Label,
		m.Reserved4,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightState) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Color,
		&m.Reserved1,
		&m.Power,
		&m.Label,
		&m.Reserved4,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightStateInfrared struct {
	Brightness uint16
}

func (m LightStateInfrared) Size() uint16 {
	return 2
}

func (m LightStateInfrared) Type() uint16 {
	return LightStateInfraredType
}

func (m LightStateInfrared) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Brightness,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightStateInfrared) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Brightness,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////

type LightStatePower struct {
	Level uint16
}

func (m LightStatePower) Size() uint16 {
	return 2
}

func (m LightStatePower) Type() uint16 {
	return LightStatePowerType
}

func (m LightStatePower) MarshalBinary() ([]byte, error) {
	b := &bytes.Buffer{}

	data := []interface{}{
		m.Level,
	}
	for _, d := range data {
		if err := binary.Write(b, endian, d); err != nil {
			return nil, err
		}
	}

	return b.Bytes(), nil
}

func (m *LightStatePower) UnmarshalBinary(data []byte) error {
	if int(m.Size()) != len(data) {
		return fmt.Errorf("expected %d bytes, got %d", m.Size(), len(data))
	}

	b := bytes.NewBuffer(data)
	vars := []interface{}{
		&m.Level,
	}
	for _, v := range vars {
		if err := binary.Read(b, endian, v); err != nil {
			return fmt.Errorf("unable to read packet: %s", err)
		}
	}

	return nil
}
